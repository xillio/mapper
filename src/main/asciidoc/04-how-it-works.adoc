= How it works

== Running Build.xill
1. The getMappings function is called.
This function recursively iterates over all folders in the root of the project. If the name of a folder is '_mappings_' all the paths to the robots inside of that folder are added to a list.

2. The generateMapper function is called.
This function reads the contents of the `_MapperTemplate` robot. This is the template for the mapper.
It contains three placeholders (`INCLUDE_MAPPING`, `IF_MAPPING`, `TYPE_MAPPING`) that will be replaced by the strings constructed in the following steps.

3. Three functions are called for each robot found in step 1.  The result of each function is appended to the corresponding variable.
    * The `addIncludeStatement` function append to the `includeStatements` variable. +
    * The `addIfStatement` function append to the `ifStatements` variable. +
    * The `addTypeStatement` function append to the  `typeStatements` variable. +

4. The saveMapper function is called. This will replace the placeholders in the template from step 2 with the variables from step 3.
   * `INCLUDE_MAPPING` is replaced with the `includeStatements` variable +
   * `IF_MAPING` is replaced with the `ifStatements` variable +
   * `TYPE_MAPPING` is replaced with the `typeStatements` variable +

5. The resulting string will be saved as `Mapper.xill` in root/config/

== Mapper.xill functions

The Mapper robot has two public functions: `mapObject and mapSourceToTargetType.

=== mapObject(object, contentType)

This function will map the object (first parameter) to the specified contentType (second parameter).

The function contains an if-statement for each contentType it could find during the creation of the Mapper.
If the provided contentType is equal to one of these contentTypes then it will run the following code:

----
include ../Example.xill as example;                        // <1>
...

var parentContentType = example->getParentTemplate();      // <2>
if(parentContentType != null && parentContentType != "") { // <3>
    foreach(type in parentContentType) {                   // <4>
        var parent = mapObject(object, type);
        result += example->mapObject(parent, object);
    }
} else {
    result = example->mapObject({}, object);                // <5>
}
----

<1> The mapping `Example.xill` gets qualified included, and its qualified name is the name of the robot. This results
    in that the functions inside the mappings may contain the same names without any conflict happening. This is also
    the reason why the mapping-robots *must* have a unique name.
<2> Call the `getParentTemplate` function from the mapping to resolve its parents.
<3> Check if the example mapping has a parentContentType.
<4> Iterate over these parentContentTypes and call mapObject on these parent mappings before calling `example->mapObject`.
    This results in that the result from the parent mapping gets enriched with the result from `example->mapObject`.
<5> The mapping does not have a parent so just call the `example->mapObject` function.

=== mapSourceToTargetType(contentType, context)

This function compares the provided contentType to the output of `getSourceType` function of each mapping.
If the provided contentType is equal to one of these then the contentType of this mapping is returned.

== Mapping.xill functions

=== getSourceType(context)

=== getParentTemplate()

=== mapObject(document, data)
