/**
 * Project: Mapper
 * Author: Titus Nachbauer, Ernst van Rheenen
 * Date: 2016-06-23
 *
 * Build.xill provides generates Mapper.xill in the appropriate config/ subfolder, 
 * which will include all mapping scripts in the mappings subfolder and runs the appropriate
 * script based on the provided ContentType.
 */

use System, Stream, File, String, Properties;

include lib.util.Util;


//-------------------------------------------------------------------------
//						  SETUP
//-------------------------------------------------------------------------

// get the build arguments passed by the calling bot or else use the defaults set in defaults.properties
argument buildSettings = {
    "mappingPath" : Properties.get("connector.export.mappingPath"),
    "mapper" : Properties.get ("connector.export.mapper"),
};

buildSettings.templatePath = Properties.get("lib.mapper.template"); 

//-------------------------------------------------------------------------
//						  MAIN
//-------------------------------------------------------------------------

buildSettings.mappings = getMappings(buildSettings.mappingPath);
buildSettings.checksum = generateChecksumFromList(buildSettings.mappings);

    System.print("buildSettings: " :: buildSettings, "debug");
    

generateMapper(buildSettings);
return buildSettings.checksum;

//-------------------------------------------------------------------------
//						  FUNCTIONS
//-------------------------------------------------------------------------

/**
* Returns any mapping robots in the provided folder, assuming it only contains 
* mapping robots.
*/
private function getMappings(mappingFolder) {
    do {
        return collect(filter<isXillFile>(File.iterateFiles(mappingFolder, false)));
    } fail (error) {
        System.print ("Error getting mapping robots: " :: error, "error");
    }
}

/**
* Generate a main mapping robot based on the provided mappings and save it
* at the provided location.
*/
private function generateMapper(buildSettings) {
    var template = getMappingBotTemplate(buildSettings.templatePath);
    var includeStatements = "";
    var ifStatements = "";
    var typeStatements = "";
    foreach (mapping in buildSettings.mappings) {
        includeStatements = addIncludeStatement(includeStatements, mapping);
        ifStatements = addIfStatement(ifStatements, mapping);
        typeStatements = addTypeStatement(typeStatements, mapping);
    }
    
    var replacements = {
    	"__INCLUDE_MAPPING__" : includeStatements, 
    	"__IF_MAPPING__" : ifStatements, 
    	"__TYPE_MAPPING__" : typeStatements, 
    	"__MAPPING_CHECKSUM__" : getChecksumStatement(buildSettings.checksum)	
    };
    saveMapper(buildSettings.mapper, template, replacements);
}

/**
* Returns the text of the mapping bot template file
*/
private function getMappingBotTemplate(templatePath) {
    do {
        var file = File.openRead(templatePath);
        return Stream.getText(file);
    } fail (error) {
        System.print ("Error opening or reading mapping bot template: " :: error, "error");
    }
}

/**
* Adds an include-statement for current mapping to the input string.
*/
private function addIncludeStatement(includeStatements, mapping) {
    var newInclude = "include " :: getMappingFQName(mapping) :: ";\n";
    
    return includeStatements :: newInclude;
}

/**
* Adds an if-statement (switch) for mapping to the input string.
*/
private function addIfStatement(ifStatements, mapping) {
    var newIf = "";
    if (ifStatements == "") {
        newIf = "	if ";
    } else {
        newIf = "	else if ";
    }
    newIf = newIf :: "(contentType == \"" :: getMappingName (mapping) :: "\") {" :: 
        getMapBlock(getMappingName(mapping)) :: "
    }";
    return ifStatements :: newIf;
}

private function getMapBlock(contentType) {
    var block = "
        var parentContentType = get__CONTENTTYPE__ParentTemplate();
        if(parentContentType != null && parentContentType != \"\") {
            foreach(type in parentContentType) {
                var parent = mapObject(object, type);
                result += map__CONTENTTYPE__(parent, object);
            }
        } else {
            result = map__CONTENTTYPE__({}, object);
        }";
    return String.replace(block, "__CONTENTTYPE__", contentType, false);
}

private function addTypeStatement(typeStatements, mapping) {
	return typeStatements :: getTypeMappingBlock(mapping);
}

private function getTypeMappingBlock(contentType) {
	contentType = getMappingName(contentType);
    var block = "
    	targetType = matchTargetType(get__CONTENTTYPE__SourceType(context), type, \"__CONTENTTYPE__\");
		if (targetType != null) { return targetType; }
		";
    return String.replace(block, "__CONTENTTYPE__", contentType, false);	
}

private function getChecksumStatement (checksum) {
    return "// Checksum: " :: checksum;
}

/**
* Save the previously generated include- and if-statements to the central mapping bot 
*/
private function saveMapper(mapperPath, template, replacements) {
	foreach(label, replacement in replacements) {
		template = String.replace(template, label, replacement, false);
	}
    saveFile(mapperPath, template);
}

/**
* Returns the checksum stored in the currently generated mapping bot or null if there is no mapping bot yet.
*/
private function getMappingChecksum(mapperPath) {
    var result = null;
    if (File.exists(mapperPath)) {
        var text = File.getText(mapperPath);
        result = String.replace(text, ".*// Checksum: ([0-9,a-f]{32}).*", "$1");
    }
    return result;
}

/**
* Returns the name of the mapping, assuming it is a path to a .xill mapping robot,
* which has the mapped contentType as file name using the correct casing.
*/
function getMappingName(mapping) {
    return toUpperCamelCase(String.replace(mapping, ".*[/\\\\]([^/\\\\]*?)\\.xill", "$1"));
}

/**
* Returns a call to a standardized mapping function with the ContentType of the current mapping
*/
function getMappingFunction(mapping) {
    return "map" :: getMappingName(mapping) :: "(object)";
}

/**
* Returns the fully qualified path used to include mapping. 
*/
function getMappingFQName(mapping) {
    var searchString = normalizeSlashes(System.info().projectPath) :: "/(.*)\\.xill";
    var relativePath = (String.replace(normalizeSlashes(mapping), searchString, "$1"));
    return (String.replace (relativePath, "[/\\\\]", "."));
}